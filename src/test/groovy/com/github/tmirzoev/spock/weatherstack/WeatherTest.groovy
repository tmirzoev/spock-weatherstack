/*
 * This Spock specification was generated by the Gradle 'init' task.
 */
package com.github.tmirzoev.spock.weatherstack

import com.github.tmirzoev.spock.weatherstack.model.QueryKeys
import com.github.tmirzoev.spock.weatherstack.model.error.WeatherStackError
import com.github.tmirzoev.spock.weatherstack.model.response.CurrentWeatherResponse

class WeatherTest extends BaseSpec {
    public def "/current endpoint should determine location by city name correctly"() {

        given: "City name and access key are correct"
        def call = weatherstackClient.getCurrentWeather(buildQueryForCity(city))

        when: "Current weather is requested from Weatherstack"
        def response = call.execute()

        then: "It should return weather info with correct location for the requested city"
        response.successful
        def responseParsed = mapper.treeToValue(response.body(), CurrentWeatherResponse)
        verifyAll(responseParsed.location) {
            name == expectedLocation.name
            country == expectedLocation.country
            region == expectedLocation.region
            lat == expectedLocation.lat
            lon == expectedLocation.lon
            timezoneId == expectedLocation.timezoneId
            utcOffset == expectedLocation.utcOffset
        }

        where:
        city               || expectedLocation
        "London"           || TestData.LONDON_LOCATION
        "Saint Petersburg" || TestData.SPB_LOCATION
        "Moscow"           || TestData.MOSCOW_LOCATION
        //This test data contains intentional errors to demonstrate test failure
        "Pushkin"          || TestData.PUSHKIN_LOCATION

    }

    public def "Requests with invalid access key should return an error"() {

        given: "Request with incorrect access key"
        def query = Map.of(QueryKeys.ACCESS_KEY.value, "incorrect",
                QueryKeys.QUERY.getValue(), "London")
        def call = weatherstackClient.getCurrentWeather(query)

        when: "Current weather is requested from Weatherstack"
        def response = call.execute()

        then: "Weatherstack returns response with status code 200 containing error with code 101"
        response.successful
        def errorParsed = mapper.treeToValue(response.body(), WeatherStackError)
        errorParsed.errorInfo == TestData.INVALID_KEY_ERROR_INFO

    }

    public def "Requests with invalid queries should return an error"() {

        given: "Request with valid access key and invalid query"
        def call = weatherstackClient.getCurrentWeather(query)

        when: "Current weather is requested from Weatherstack"
        def response = call.execute()

        then: "Weatherstack returns response with status code 200 containing error code and description"
        response.successful
        def errorParsed = mapper.treeToValue(response.body(), WeatherStackError)
        errorParsed.errorInfo == expectedErrorInfo

        where:
        query << [buildQueryForCity(""), buildQueryForCity("unknown")]
        expectedErrorInfo << [TestData.MISSING_QUERY_ERROR_INFO, TestData.REQUEST_FAILED_ERROR_INFO]

    }

    public def "Historical requests should return an error if the user's plan does not support them"() {

        given: "Request with access key that does not support such requests"
        def query = buildQueryForCity("London")
        def call = weatherstackClient.getHistoricalWeather(query)

        when: "Historical weather is requested from Weatherstack"
        def response = call.execute()

        then: "Weatherstack returns response with status code 200 containing error code and description"
        response.successful
        def errorParsed = mapper.treeToValue(response.body(), WeatherStackError)
        errorParsed.errorInfo == TestData.HISTORICAL_NOT_SUPPORTED_ERROR_INFO

    }

    private Map<String, String> buildQueryForCity(String city) {
        Map.of(
                QueryKeys.ACCESS_KEY.value, apiKey,
                QueryKeys.QUERY.value, city
        )
    }
}
